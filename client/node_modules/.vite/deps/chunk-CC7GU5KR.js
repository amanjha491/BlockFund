import {
  getInjectedMetamaskProvider
} from "./chunk-XEMVC7YF.js";
import {
  Ar,
  B2 as B,
  D,
  Ft,
  N,
  Qt,
  Vn,
  _,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  gs,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  jt,
  q,
  require_cjs,
  require_cjs2,
  require_random,
  require_sha256
} from "./chunk-RGGFJCXW.js";
import {
  getInjectedPhantomProvider
} from "./chunk-X37GOLOZ.js";
import {
  getInjectedRainbowProvider
} from "./chunk-DQKQTS6I.js";
import {
  assertWindowEthereum
} from "./chunk-R754QN4Y.js";
import {
  Connector,
  WagmiAdapter
} from "./chunk-IZMACNVN.js";
import {
  e,
  i
} from "./chunk-LNMBKCSI.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-FHB7QQX6.js";
import {
  walletIds
} from "./chunk-CCOHFGPM.js";
import {
  normalizeChainId
} from "./chunk-UIMLRAPE.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-I5FN74TN.js";
import {
  _defineProperty
} from "./chunk-PBE5HDMX.js";
import {
  require_events
} from "./chunk-JDINXBDD.js";
import {
  NATIVE_TOKEN_ADDRESS,
  fetchCurrencyValue,
  isNativeToken,
  normalizePriceValue
} from "./chunk-5MEYIYGT.js";
import {
  require_utils
} from "./chunk-ZU2U5RAQ.js";
import {
  c1,
  defaultChains,
  updateChainRPCs
} from "./chunk-ALBJIJQL.js";
import {
  eventemitter3_default
} from "./chunk-YXRFDYBT.js";
import {
  require_buffer
} from "./chunk-7MYXWFDC.js";
import {
  Contract,
  Wallet,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-F2MSCHKS.js";
import {
  Signer,
  getDefaultProvider,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  lib_exports19 as lib_exports,
  recoverAddress
} from "./chunk-H2SRY3HK.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-EUIKE2YQ.js";

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e2, n) {
  return n = n || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o2 = [], u2 = [], i2 = {}, a = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u2;
      }, get: function(e3) {
        return i2[e3.toLowerCase()];
      }, has: function(e3) {
        return e3.toLowerCase() in i2;
      } } };
    };
    for (var l2 in s.open(n.method || "get", e2, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e3, n2, t2) {
        o2.push(n2 = n2.toLowerCase()), u2.push([n2, t2]), i2[n2] = i2[n2] ? i2[n2] + "," + t2 : t2;
      }), t(a());
    }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers)
      s.setRequestHeader(l2, n.headers[l2]);
    s.send(n.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_lib3();
var ERC20WithDecimalsAbi = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "who",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
    internalType: "uint8",
    name: "",
    type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}];
function createErc20(provider, currencyAddress) {
  return new Contract(currencyAddress, ERC20WithDecimalsAbi, provider);
}
function chainIdToThirdwebRpc(chainId, clientId) {
  return `https://${chainId}.rpc.thirdweb.com${clientId ? `/${clientId}` : ""}${typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? `?bundleId=${globalThis.APP_BUNDLE_ID}` : ""}`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  /**
   * @returns the account address from connected wallet
   */
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  /**
   * @returns the native token balance of the connected wallet
   */
  async getBalance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const address = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await signer.provider.getBalance(address);
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      balance = await erc20.balanceOf(address);
    }
    return await fetchCurrencyValue(signer.provider, currencyAddress, balance);
  }
  /**
   * @returns the chain id from connected wallet
   */
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const from = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    const value = await normalizePriceValue(signer.provider, amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const tx = await signer.sendTransaction({
        from,
        to,
        value
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      const tx = await erc20.transfer(to, value);
      return {
        receipt: await tx.wait()
      };
    }
  }
  /**
   * @returns the signature of the message
   */
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  /**
   * verify the signature of a message
   * @returns `true` if the signature is valid, `false` otherwise
   */
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-402f7b12.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e2) {
        rej(e2);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c) => updateChainRPCs(c, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * tries to auto connect to the wallet
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  /**
   * connect to the wallet
   */
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c) => {
      var _a;
      return updateChainRPCs(c, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses a personal wallet under the hood, return it
   */
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address,
      chainId: await this.getChainId()
    });
    return address;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  try {
    const address = await connector.connect(connectOptions);
    return address;
  } catch (error) {
    throw new Error(error.message);
  }
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data2) => {
    var _a;
    this.emit("connect", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data2) => {
    var _a;
    this.emit("change", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data2) => {
    this.emit("message", data2);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_logger = __toESM(require_cjs2());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time.ONE_DAY, prompt: false, tag: 3001 } } };
var U = { min: import_time.FIVE_MINUTES, max: import_time.SEVEN_DAYS };
var $ = "wc";
var Q = 1;
var Z = "auth";
var B2 = "authClient";
var F = `${$}@${1}:${Z}:`;
var x = `${F}:PUB_KEY`;
function z(r) {
  return r == null ? void 0 : r.split(":");
}
function Ze(r) {
  const t = r && z(r);
  if (t)
    return t[3];
}
function We(r) {
  const t = r && z(r);
  if (t)
    return t[2] + ":" + t[3];
}
function W(r) {
  const t = r && z(r);
  if (t)
    return t.pop();
}
async function et(r, t, e2, i2, n) {
  switch (e2.t) {
    case "eip191":
      return tt(r, t, e2.s);
    case "eip1271":
      return await rt(r, t, e2.s, i2, n);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e2.t}`);
  }
}
function tt(r, t, e2) {
  return recoverAddress(hashMessage(t), e2).toLowerCase() === r.toLowerCase();
}
async function rt(r, t, e2, i2, n) {
  try {
    const s = "0x1626ba7e", o2 = "0000000000000000000000000000000000000000000000000000000000000040", u2 = "0000000000000000000000000000000000000000000000000000000000000041", a = e2.substring(2), c = hashMessage(t).substring(2), h = s + c + o2 + u2 + a, f2 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i2}&projectId=${n}`, { method: "POST", body: JSON.stringify({ id: it(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h }, "latest"] }) }), { result: p2 } = await f2.json();
    return p2 ? p2.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function it() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function te(r, t) {
  return ee(r).find((e2) => e2.id === t);
}
function nt(r) {
  const t = jt(r.aud), e2 = new RegExp(`${r.domain}`).test(r.aud), i2 = !!r.nonce, n = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !Qt(s, U)) {
    const { message: o2 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);
    throw new Error(o2);
  }
  return !!(t && e2 && i2 && n);
}
function st(r, t) {
  return !!te(t, r.id);
}
function ot(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function ut(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e2 = new Uint8Array(256), i2 = 0; i2 < e2.length; i2++)
    e2[i2] = 255;
  for (var n = 0; n < r.length; n++) {
    var s = r.charAt(n), o2 = s.charCodeAt(0);
    if (e2[o2] !== 255)
      throw new TypeError(s + " is ambiguous");
    e2[o2] = n;
  }
  var u2 = r.length, a = r.charAt(0), c = Math.log(u2) / Math.log(256), h = Math.log(256) / Math.log(u2);
  function f2(D3) {
    if (D3 instanceof Uint8Array || (ArrayBuffer.isView(D3) ? D3 = new Uint8Array(D3.buffer, D3.byteOffset, D3.byteLength) : Array.isArray(D3) && (D3 = Uint8Array.from(D3))), !(D3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D3.length === 0)
      return "";
    for (var l2 = 0, m2 = 0, E2 = 0, y2 = D3.length; E2 !== y2 && D3[E2] === 0; )
      E2++, l2++;
    for (var w2 = (y2 - E2) * h + 1 >>> 0, g2 = new Uint8Array(w2); E2 !== y2; ) {
      for (var C2 = D3[E2], _3 = 0, b2 = w2 - 1; (C2 !== 0 || _3 < m2) && b2 !== -1; b2--, _3++)
        C2 += 256 * g2[b2] >>> 0, g2[b2] = C2 % u2 >>> 0, C2 = C2 / u2 >>> 0;
      if (C2 !== 0)
        throw new Error("Non-zero carry");
      m2 = _3, E2++;
    }
    for (var v = w2 - m2; v !== w2 && g2[v] === 0; )
      v++;
    for (var q2 = a.repeat(l2); v < w2; ++v)
      q2 += r.charAt(g2[v]);
    return q2;
  }
  function p2(D3) {
    if (typeof D3 != "string")
      throw new TypeError("Expected String");
    if (D3.length === 0)
      return new Uint8Array();
    var l2 = 0;
    if (D3[l2] !== " ") {
      for (var m2 = 0, E2 = 0; D3[l2] === a; )
        m2++, l2++;
      for (var y2 = (D3.length - l2) * c + 1 >>> 0, w2 = new Uint8Array(y2); D3[l2]; ) {
        var g2 = e2[D3.charCodeAt(l2)];
        if (g2 === 255)
          return;
        for (var C2 = 0, _3 = y2 - 1; (g2 !== 0 || C2 < E2) && _3 !== -1; _3--, C2++)
          g2 += u2 * w2[_3] >>> 0, w2[_3] = g2 % 256 >>> 0, g2 = g2 / 256 >>> 0;
        if (g2 !== 0)
          throw new Error("Non-zero carry");
        E2 = C2, l2++;
      }
      if (D3[l2] !== " ") {
        for (var b2 = y2 - E2; b2 !== y2 && w2[b2] === 0; )
          b2++;
        for (var v = new Uint8Array(m2 + (y2 - b2)), q2 = m2; b2 !== y2; )
          v[q2++] = w2[b2++];
        return v;
      }
    }
  }
  function A(D3) {
    var l2 = p2(D3);
    if (l2)
      return l2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f2, decodeUnsafe: p2, decode: A };
}
var at = ut;
var Dt = at;
var re = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r) => new TextEncoder().encode(r);
var ht = (r) => new TextDecoder().decode(r);
var lt = class {
  constructor(t, e2, i2) {
    this.name = t, this.prefix = e2, this.baseEncode = i2;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt = class {
  constructor(t, e2, i2) {
    if (this.name = t, this.prefix = e2, e2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e2.codePointAt(0), this.baseDecode = i2;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie(this, t);
  }
};
var pt = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie(this, t);
  }
  decode(t) {
    const e2 = t[0], i2 = this.decoders[e2];
    if (i2)
      return i2.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie = (r, t) => new pt({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var ft = class {
  constructor(t, e2, i2, n) {
    this.name = t, this.prefix = e2, this.baseEncode = i2, this.baseDecode = n, this.encoder = new lt(t, e2, i2), this.decoder = new dt(t, e2, n);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O = ({ name: r, prefix: t, encode: e2, decode: i2 }) => new ft(r, t, e2, i2);
var T = ({ prefix: r, name: t, alphabet: e2 }) => {
  const { encode: i2, decode: n } = Dt(e2, t);
  return O({ prefix: r, name: t, encode: i2, decode: (s) => re(n(s)) });
};
var gt = (r, t, e2, i2) => {
  const n = {};
  for (let h = 0; h < t.length; ++h)
    n[t[h]] = h;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o2 = new Uint8Array(s * e2 / 8 | 0);
  let u2 = 0, a = 0, c = 0;
  for (let h = 0; h < s; ++h) {
    const f2 = n[r[h]];
    if (f2 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    a = a << e2 | f2, u2 += e2, u2 >= 8 && (u2 -= 8, o2[c++] = 255 & a >> u2);
  }
  if (u2 >= e2 || 255 & a << 8 - u2)
    throw new SyntaxError("Unexpected end of data");
  return o2;
};
var Et = (r, t, e2) => {
  const i2 = t[t.length - 1] === "=", n = (1 << e2) - 1;
  let s = "", o2 = 0, u2 = 0;
  for (let a = 0; a < r.length; ++a)
    for (u2 = u2 << 8 | r[a], o2 += 8; o2 > e2; )
      o2 -= e2, s += t[n & u2 >> o2];
  if (o2 && (s += t[n & u2 << e2 - o2]), i2)
    for (; s.length * e2 & 7; )
      s += "=";
  return s;
};
var d = ({ name: r, prefix: t, bitsPerChar: e2, alphabet: i2 }) => O({ prefix: t, name: r, encode(n) {
  return Et(n, i2, e2);
}, decode(n) {
  return gt(n, i2, e2, r);
} });
var bt = O({ prefix: "\0", name: "identity", encode: (r) => ht(r), decode: (r) => ct(r) });
var yt = Object.freeze({ __proto__: null, identity: bt });
var wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
var mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
var At = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
var xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft2 = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
var Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t });
var zt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt2 });
var Lt = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
var kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
var ne = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Yt = ne.reduce((r, t, e2) => (r[e2] = t, r), []);
var Qt2 = ne.reduce((r, t, e2) => (r[t.codePointAt(0)] = e2, r), []);
function Zt(r) {
  return r.reduce((t, e2) => (t += Yt[e2], t), "");
}
function Wt(r) {
  const t = [];
  for (const e2 of r) {
    const i2 = Qt2[e2.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${e2}`);
    t.push(i2);
  }
  return new Uint8Array(t);
}
var er = O({ prefix: "🚀", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er });
var rr = oe;
var se = 128;
var ir = 127;
var nr = ~ir;
var sr = Math.pow(2, 31);
function oe(r, t, e2) {
  t = t || [], e2 = e2 || 0;
  for (var i2 = e2; r >= sr; )
    t[e2++] = r & 255 | se, r /= 128;
  for (; r & nr; )
    t[e2++] = r & 255 | se, r >>>= 7;
  return t[e2] = r | 0, oe.bytes = e2 - i2 + 1, t;
}
var or = j;
var ur = 128;
var ue = 127;
function j(r, i2) {
  var e2 = 0, i2 = i2 || 0, n = 0, s = i2, o2, u2 = r.length;
  do {
    if (s >= u2)
      throw j.bytes = 0, new RangeError("Could not decode varint");
    o2 = r[s++], e2 += n < 28 ? (o2 & ue) << n : (o2 & ue) * Math.pow(2, n), n += 7;
  } while (o2 >= ur);
  return j.bytes = s - i2, e2;
}
var ar = Math.pow(2, 7);
var Dr = Math.pow(2, 14);
var cr = Math.pow(2, 21);
var hr = Math.pow(2, 28);
var lr = Math.pow(2, 35);
var dr = Math.pow(2, 42);
var pr = Math.pow(2, 49);
var fr = Math.pow(2, 56);
var gr = Math.pow(2, 63);
var Er = function(r) {
  return r < ar ? 1 : r < Dr ? 2 : r < cr ? 3 : r < hr ? 4 : r < lr ? 5 : r < dr ? 6 : r < pr ? 7 : r < fr ? 8 : r < gr ? 9 : 10;
};
var br = { encode: rr, decode: or, encodingLength: Er };
var ae = br;
var De = (r, t, e2 = 0) => (ae.encode(r, t, e2), t);
var ce = (r) => ae.encodingLength(r);
var M = (r, t) => {
  const e2 = t.byteLength, i2 = ce(r), n = i2 + ce(e2), s = new Uint8Array(n + e2);
  return De(r, s, 0), De(e2, s, i2), s.set(t, n), new yr(r, e2, t, s);
};
var yr = class {
  constructor(t, e2, i2, n) {
    this.code = t, this.size = e2, this.digest = i2, this.bytes = n;
  }
};
var he = ({ name: r, code: t, encode: e2 }) => new wr(r, t, e2);
var wr = class {
  constructor(t, e2, i2) {
    this.name = t, this.code = e2, this.encode = i2;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e2 = this.encode(t);
      return e2 instanceof Uint8Array ? M(this.code, e2) : e2.then((i2) => M(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") });
var mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
var de = 0;
var Ar2 = "identity";
var pe = re;
var _r = (r) => M(de, pe(r));
var xr = { code: de, name: Ar2, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
var fe = { ...yt, ...Ct, ...vt, ..._t, ...Ft2, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(r, t, e2, i2) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e2 }, decoder: { decode: i2 } };
}
var Ee = ge("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var L = ge("ascii", "a", (r) => {
  let t = "a";
  for (let e2 = 0; e2 < r.length; e2++)
    t += String.fromCharCode(r[e2]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = ot(r.length);
  for (let e2 = 0; e2 < r.length; e2++)
    t[e2] = r.charCodeAt(e2);
  return t;
});
var be = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L, ascii: L, binary: L, ...fe };
function Fr(r, t = "utf8") {
  const e2 = be[t];
  if (!e2)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e2.decoder.decode(`${e2.prefix}${r}`);
}
function Tr(r, t = "utf8") {
  const e2 = be[t];
  if (!e2)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e2.encoder.encode(r).substring(1);
}
var ye = "base16";
var we = "utf8";
function K(r) {
  const t = (0, import_sha256.hash)(Fr(r, we));
  return Tr(t, ye);
}
var Or = Object.defineProperty;
var Sr = Object.defineProperties;
var Pr = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var $r = Object.prototype.propertyIsEnumerable;
var me = (r, t, e2) => t in r ? Or(r, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r[t] = e2;
var I = (r, t) => {
  for (var e2 in t || (t = {}))
    Nr.call(t, e2) && me(r, e2, t[e2]);
  if (Ce)
    for (var e2 of Ce(t))
      $r.call(t, e2) && me(r, e2, t[e2]);
  return r;
};
var V = (r, t) => Sr(r, Pr(t));
var Br = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e2, i2) => {
      if (this.isInitialized(), !nt(e2))
        throw new Error("Invalid request");
      if (i2 != null && i2.topic)
        return await this.requestOnKnownPairing(i2.topic, e2);
      const { chainId: n, statement: s, aud: o2, domain: u2, nonce: a, type: c, exp: h, nbf: f2 } = e2, { topic: p2, uri: A } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p2, uri: A } });
      const D3 = await this.client.core.crypto.generateKeyPair(), l2 = Vn(D3);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: D3 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: p2 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${p2}`);
      const m2 = await this.sendRequest(p2, "wc_authRequest", { payloadParams: { type: c ?? "eip4361", chainId: n, statement: s, aud: o2, domain: u2, version: "1", nonce: a, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h, nbf: f2 }, requester: { publicKey: D3, metadata: this.client.metadata } }, {}, e2.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p2}`), { uri: A, id: m2 };
    }, this.respond = async (e2, i2) => {
      if (this.isInitialized(), !st(e2, this.client.requests))
        throw new Error("Invalid response");
      const n = te(this.client.requests, e2.id);
      if (!n)
        throw new Error(`Could not find pending auth request with id ${e2.id}`);
      const s = n.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), u2 = Vn(s), a = { type: _, receiverPublicKey: s, senderPublicKey: o2 };
      if ("error" in e2) {
        await this.sendError(n.id, u2, e2, a);
        return;
      }
      const c = { h: { t: "eip4361" }, p: V(I({}, n.cacaoPayload), { iss: i2 }), s: e2.signature };
      await this.sendResult(n.id, u2, c, a), await this.client.core.pairing.activate({ topic: n.pairingTopic }), await this.client.requests.update(n.id, I({}, c));
    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (e2, i2) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e2)}`);
      const n = `${e2.domain} wants you to sign in with your Ethereum account:`, s = W(i2), o2 = e2.statement, u2 = `URI: ${e2.aud}`, a = `Version: ${e2.version}`, c = `Chain ID: ${Ze(i2)}`, h = `Nonce: ${e2.nonce}`, f2 = `Issued At: ${e2.iat}`, p2 = e2.exp ? `Expiry: ${e2.exp}` : void 0, A = e2.resources && e2.resources.length > 0 ? `Resources:
${e2.resources.map((D3) => `- ${D3}`).join(`
`)}` : void 0;
      return [n, s, "", o2, "", u2, a, c, h, f2, p2, A].filter((D3) => D3 != null).join(`
`);
    }, this.setExpiry = async (e2, i2) => {
      this.client.core.pairing.pairings.keys.includes(e2) && await this.client.core.pairing.updateExpiry({ topic: e2, expiry: i2 }), this.client.core.expirer.set(e2, i2);
    }, this.sendRequest = async (e2, i2, n, s, o2) => {
      const u2 = formatJsonRpcRequest(i2, n), a = await this.client.core.crypto.encode(e2, u2, s), c = R[i2].req;
      if (o2 && (c.ttl = o2), this.client.core.history.set(e2, u2), q()) {
        const h = K(JSON.stringify(u2));
        this.client.core.verify.register({ attestationId: h });
      }
      return await this.client.core.relayer.publish(e2, a, V(I({}, c), { internal: { throwOnFailedPublish: true } })), u2.id;
    }, this.sendResult = async (e2, i2, n, s) => {
      const o2 = formatJsonRpcResult(e2, n), u2 = await this.client.core.crypto.encode(i2, o2, s), a = await this.client.core.history.get(i2, e2), c = R[a.request.method].res;
      return await this.client.core.relayer.publish(i2, u2, V(I({}, c), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o2), o2.id;
    }, this.sendError = async (e2, i2, n, s) => {
      const o2 = formatJsonRpcError(e2, n.error), u2 = await this.client.core.crypto.encode(i2, o2, s), a = await this.client.core.history.get(i2, e2), c = R[a.request.method].res;
      return await this.client.core.relayer.publish(i2, u2, c), await this.client.core.history.resolve(o2), o2.id;
    }, this.requestOnKnownPairing = async (e2, i2) => {
      const n = this.client.core.pairing.pairings.getAll({ active: true }).find((A) => A.topic === e2);
      if (!n)
        throw new Error(`Could not find pairing for provided topic ${e2}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: o2, statement: u2, aud: a, domain: c, nonce: h, type: f2 } = i2, p2 = await this.sendRequest(n.topic, "wc_authRequest", { payloadParams: { type: f2 ?? "eip4361", chainId: o2, statement: u2, aud: a, domain: c, version: "1", nonce: h, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i2.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n.topic}`), { id: p2 };
    }, this.onPairingCreated = (e2) => {
      const i2 = this.getPendingRequests();
      if (i2) {
        const n = Object.values(i2).find((s) => s.pairingTopic === e2.topic);
        n && this.handleAuthRequest(n);
      }
    }, this.onRelayEventRequest = (e2) => {
      const { topic: i2, payload: n } = e2, s = n.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i2, n);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: i2, payload: n } = e2, s = (await this.client.core.history.get(i2, n.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i2, n);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e2, i2) => {
      const { requester: n, payloadParams: s } = i2.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e2, payload: i2 });
      const o2 = K(JSON.stringify(i2)), u2 = await this.getVerifyContext(o2, this.client.metadata), a = { requester: n, pairingTopic: e2, id: i2.id, cacaoPayload: s, verifyContext: u2 };
      await this.client.requests.set(i2.id, a), this.handleAuthRequest(a);
    }, this.handleAuthRequest = async (e2) => {
      const { id: i2, pairingTopic: n, requester: s, cacaoPayload: o2, verifyContext: u2 } = e2;
      try {
        this.client.emit("auth_request", { id: i2, topic: n, params: { requester: s, cacaoPayload: o2 }, verifyContext: u2 });
      } catch (a) {
        await this.sendError(e2.id, e2.pairingTopic, a), this.client.logger.error(a);
      }
    }, this.onAuthResponse = async (e2, i2) => {
      const { id: n } = i2;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e2, response: i2 }), isJsonRpcResult(i2)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e2);
        await this.client.core.pairing.activate({ topic: s });
        const { s: o2, p: u2 } = i2.result;
        await this.client.requests.set(n, I({ id: n, pairingTopic: s }, i2.result));
        const a = this.formatMessage(u2, u2.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a)), this.client.logger.debug("payload.iss:", u2.iss), this.client.logger.debug("signature:", o2);
        const c = W(u2.iss), h = We(u2.iss);
        if (!c)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c), await et(c, a, o2, h, this.client.projectId) ? this.client.emit("auth_response", { id: n, topic: e2, params: i2 }) : this.client.emit("auth_response", { id: n, topic: e2, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i2) && this.client.emit("auth_response", { id: n, topic: e2, params: i2 });
    }, this.getVerifyContext = async (e2, i2) => {
      const n = { verified: { verifyUrl: i2.verifyUrl || "", validation: "UNKNOWN", origin: i2.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: i2.verifyUrl });
        s && (n.verified.origin = s.origin, n.verified.isScam = s.isScam, n.verified.validation = origin === new URL(i2.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n)}`), n;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t) => {
      const { topic: e2, message: i2 } = t, { responseTopic: n, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n && e2 !== n) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e2);
        return;
      }
      const o2 = await this.client.core.crypto.decode(e2, i2, { receiverPublicKey: s });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e2, o2), this.onRelayEventRequest({ topic: e2, payload: o2 })) : isJsonRpcResponse(o2) && (await this.client.core.history.resolve(o2), this.onRelayEventResponse({ topic: e2, payload: o2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(B.create, (t) => this.onPairingCreated(t));
  }
};
var S = class _S extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B2, this.events = new import_events.EventEmitter(), this.emit = (i2, n) => this.events.emit(i2, n), this.on = (i2, n) => this.events.on(i2, n), this.once = (i2, n) => this.events.once(i2, n), this.off = (i2, n) => this.events.off(i2, n), this.removeListener = (i2, n) => this.events.removeListener(i2, n), this.request = async (i2, n) => {
      try {
        return await this.engine.request(i2, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i2, n) => {
      try {
        return await this.engine.respond(i2, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.formatMessage = (i2, n) => {
      try {
        return this.engine.formatMessage(i2, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e2 = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Ar(t), this.logger = (0, import_logger.generateChildLogger)(e2, this.name), this.authKeys = new Ft(this.core, this.logger, "authKeys", F, () => x), this.pairingTopics = new Ft(this.core, this.logger, "pairingTopics", F), this.requests = new Ft(this.core, this.logger, "requests", F, (i2) => i2.id), this.engine = new Br(this);
  }
  static async init(t) {
    const e2 = new _S(t);
    return await e2.initialize(), e2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr = S;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u = typeof Reflect == "object" ? Reflect : null;
var m = u && typeof u.apply == "function" ? u.apply : function(t, e2, n) {
  return Function.prototype.apply.call(t, e2, n);
};
var f;
u && typeof u.ownKeys == "function" ? f = u.ownKeys : Object.getOwnPropertySymbols ? f = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f = function(t) {
  return Object.getOwnPropertyNames(t);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M2, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w = 10;
function g(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || y(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function L2(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L2(this);
}, o.prototype.emit = function(t) {
  for (var e2 = [], n = 1; n < arguments.length; n++)
    e2.push(arguments[n]);
  var i2 = t === "error", a = this._events;
  if (a !== void 0)
    i2 = i2 && a.error === void 0;
  else if (!i2)
    return false;
  if (i2) {
    var r;
    if (e2.length > 0 && (r = e2[0]), r instanceof Error)
      throw r;
    var h = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw h.context = r, h;
  }
  var c = a[t];
  if (c === void 0)
    return false;
  if (typeof c == "function")
    m(c, this, e2);
  else
    for (var v = c.length, A = b(c, v), n = 0; n < v; ++n)
      m(A[n], this, e2);
  return true;
};
function _2(s, t, e2, n) {
  var i2, a, r;
  if (g(e2), a = s._events, a === void 0 ? (a = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a.newListener !== void 0 && (s.emit("newListener", t, e2.listener ? e2.listener : e2), a = s._events), r = a[t]), r === void 0)
    r = a[t] = e2, ++s._eventsCount;
  else if (typeof r == "function" ? r = a[t] = n ? [e2, r] : [r, e2] : n ? r.unshift(e2) : r.push(e2), i2 = L2(s), i2 > 0 && r.length > i2 && !r.warned) {
    r.warned = true;
    var h = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h.name = "MaxListenersExceededWarning", h.emitter = s, h.type = t, h.count = r.length, T2(h);
  }
  return s;
}
o.prototype.addListener = function(t, e2) {
  return _2(this, t, e2, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e2) {
  return _2(this, t, e2, true);
};
function j2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S2(s, t, e2) {
  var n = { fired: false, wrapFn: void 0, target: s, type: t, listener: e2 }, i2 = j2.bind(n);
  return i2.listener = e2, n.wrapFn = i2, i2;
}
o.prototype.once = function(t, e2) {
  return g(e2), this.on(t, S2(this, t, e2)), this;
}, o.prototype.prependOnceListener = function(t, e2) {
  return g(e2), this.prependListener(t, S2(this, t, e2)), this;
}, o.prototype.removeListener = function(t, e2) {
  var n, i2, a, r, h;
  if (g(e2), i2 = this._events, i2 === void 0)
    return this;
  if (n = i2[t], n === void 0)
    return this;
  if (n === e2 || n.listener === e2)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[t], i2.removeListener && this.emit("removeListener", t, n.listener || e2));
  else if (typeof n != "function") {
    for (a = -1, r = n.length - 1; r >= 0; r--)
      if (n[r] === e2 || n[r].listener === e2) {
        h = n[r].listener, a = r;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? n.shift() : I2(n, a), n.length === 1 && (i2[t] = n[0]), i2.removeListener !== void 0 && this.emit("removeListener", t, h || e2);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e2, n, i2;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var a = Object.keys(n), r;
    for (i2 = 0; i2 < a.length; ++i2)
      r = a[i2], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e2 = n[t], typeof e2 == "function")
    this.removeListener(t, e2);
  else if (e2 !== void 0)
    for (i2 = e2.length - 1; i2 >= 0; i2--)
      this.removeListener(t, e2[i2]);
  return this;
};
function C(s, t, e2) {
  var n = s._events;
  if (n === void 0)
    return [];
  var i2 = n[t];
  return i2 === void 0 ? [] : typeof i2 == "function" ? e2 ? [i2.listener || i2] : [i2] : e2 ? W2(i2) : b(i2, i2.length);
}
o.prototype.listeners = function(t) {
  return C(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return C(this, t, false);
}, o.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : E.call(s, t);
}, o.prototype.listenerCount = E;
function E(s) {
  var t = this._events;
  if (t !== void 0) {
    var e2 = t[s];
    if (typeof e2 == "function")
      return 1;
    if (e2 !== void 0)
      return e2.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function b(s, t) {
  for (var e2 = new Array(t), n = 0; n < t; ++n)
    e2[n] = s[n];
  return e2;
}
function I2(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function W2(s) {
  for (var t = new Array(s.length), e2 = 0; e2 < t.length; ++e2)
    t[e2] = s[e2].listener || s[e2];
  return t;
}
function M2(s, t) {
  return new Promise(function(e2, n) {
    function i2(r) {
      s.removeListener(t, a), n(r);
    }
    function a() {
      typeof s.removeListener == "function" && s.removeListener("error", i2), e2([].slice.call(arguments));
    }
    R2(s, t, a, { once: true }), t !== "error" && z2(s, i2, { once: true });
  });
}
function z2(s, t, e2) {
  typeof s.on == "function" && R2(s, "error", t, e2);
}
function R2(s, t, e2, n) {
  if (typeof s.on == "function")
    n.once ? s.once(t, e2) : s.on(t, e2);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i2(a) {
      n.once && s.removeEventListener(t, i2), e2(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O2 = "wc";
var d2 = "Web3Wallet";
var K2 = `${O2}@2:${d2}:`;
var X = class extends l.exports {
  constructor() {
    super();
  }
};
var x2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P = class {
  constructor(t) {
    this.client = t;
  }
};
var D2 = class extends P {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await gs.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await zr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e2) => {
      await this.client.core.pairing.pair(e2);
    }, this.approveSession = async (e2) => {
      const { topic: n, acknowledged: i2 } = await this.signClient.approve({ id: e2.id, namespaces: e2.namespaces });
      return await i2(), this.signClient.session.get(n);
    }, this.rejectSession = async (e2) => await this.signClient.reject(e2), this.updateSession = async (e2) => await (await this.signClient.update(e2)).acknowledged(), this.extendSession = async (e2) => await (await this.signClient.extend(e2)).acknowledged(), this.respondSessionRequest = async (e2) => await this.signClient.respond(e2), this.disconnectSession = async (e2) => await this.signClient.disconnect(e2), this.emitSessionEvent = async (e2) => await this.signClient.emit(e2), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e2, n) => (e2[n.topic] = n, e2), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e2, n) => await this.authClient.respond(e2, n), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e2) => "requester" in e2), this.formatMessage = (e2, n) => this.authClient.formatMessage(e2, n), this.onSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onSessionProposal = (e2) => {
      this.client.events.emit("session_proposal", e2);
    }, this.onSessionDelete = (e2) => {
      this.client.events.emit("session_delete", e2);
    }, this.onAuthRequest = (e2) => {
      this.client.events.emit("auth_request", e2);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p = class _p extends x2 {
  constructor(t) {
    super(t), this.events = new l.exports(), this.on = (e2, n) => this.events.on(e2, n), this.once = (e2, n) => this.events.once(e2, n), this.off = (e2, n) => this.events.off(e2, n), this.removeListener = (e2, n) => this.events.removeListener(e2, n), this.pair = async (e2) => {
      try {
        return await this.engine.pair(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.approveSession = async (e2) => {
      try {
        return await this.engine.approveSession(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.rejectSession = async (e2) => {
      try {
        return await this.engine.rejectSession(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.updateSession = async (e2) => {
      try {
        return await this.engine.updateSession(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.extendSession = async (e2) => {
      try {
        return await this.engine.extendSession(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.respondSessionRequest = async (e2) => {
      try {
        return await this.engine.respondSessionRequest(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.disconnectSession = async (e2) => {
      try {
        return await this.engine.disconnectSession(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.emitSessionEvent = async (e2) => {
      try {
        return await this.engine.emitSessionEvent(e2);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.respondAuthRequest = async (e2, n) => {
      try {
        return await this.engine.respondAuthRequest(e2, n);
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.formatMessage = (e2, n) => {
      try {
        return this.engine.formatMessage(e2, n);
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.metadata = t.metadata, this.name = t.name || d2, this.core = t.core, this.logger = this.core.logger, this.engine = new D2(this);
  }
  static async init(t) {
    const e2 = new _p(t);
    return await e2.initialize(), e2;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var G2 = p;

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-98b00e2e.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-98b00e2e.browser.esm.js
var WalletConnectHandler = class extends eventemitter3_default {
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet$1 = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners$1 = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new Ar({
      projectId: (options == null ? void 0 : options.walletConenctV2ProjectId) || TW_WC_PROJECT_ID,
      relayUrl: (options == null ? void 0 : options.walletConnectV2RelayUrl) || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet$1, await G2.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2$1() {
  if (!_classPrivateFieldGet(this, _wcWallet$1)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$1).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p2) => !utils_exports.isAddress(p2))[0] || "";
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}
var NoOpWalletConnectHandler = class extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  disconnectSession() {
    return Promise.resolve();
  }
};
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    super(_SmartWallet.id, {
      ...options
    });
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _defineProperty(this, "enableConnectApp", false);
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    this.enableConnectApp = (options == null ? void 0 : options.enableConnectApp) || false;
    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? new WalletConnectV2Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options == null ? void 0 : options.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler());
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await _classPrivateFieldGet(this, _wcWallet).init();
        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
      }
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-D2OZU4HI.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction the transaction to execute using the smart wallet.
   * @returns whether the connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Execute a single transaction
   * @param transactions
   * @returns the transaction receipt
   */
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  /**
   * Execute multiple transactions in a single batch
   * @param transactions
   * @returns the transaction receipt
   */
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deployIfNeeded() {
    const connector = await this.getConnector();
    return connector.deployIfNeeded();
  }
  /**
   * Check if the smart wallet contract is deployed
   * @returns true if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the smart wallet.
   * @param keyAddress the address of the session key to add.
   * @param permissions the permissions to grant to the session key.
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Remove a session key from the smart wallet.
   * @param keyAddress the address of the session key to remove.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress the address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress the address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns the account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns the account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
  // wcv2
  async connectApp(uri) {
    var _a;
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.connectApp(uri);
  }
  async approveSession() {
    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return _classPrivateFieldGet(this, _wcWallet).rejectSession();
  }
  approveRequest() {
    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);
  }
  rejectRequest() {
    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
  }
  disconnectSession() {
    var _a;
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    this.emit("message", {
      type: "session_proposal",
      data: proposal
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", () => {
    this.emit("message", {
      type: "session_delete"
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("switch_chain", (request) => {
    const chainId = request.params[0].chainId;
    this.emit("message", {
      type: "switch_chain",
      data: {
        chainId
      }
    });
    _classPrivateFieldGet(this, _wcWallet).disconnectSession();
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", (request) => {
    this.emit("message", {
      type: "session_request",
      data: request
    });
  });
}
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-980f40a9.browser.esm.js
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a;
    super(_PaperWallet.id, {
      ...options
    });
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      this.chain = options.chain;
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.chain = options.chain;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-UDNRGJIP.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  constructor(options) {
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-7PFFNNCW.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-QI4OP6JV.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/embedded-wallet-3d179c50.browser.esm.js
init_lib3();
var import_utils2 = __toESM(require_utils());
var EMBEDDED_WALLET_PATH = "/sdk/2022-08-12/embedded-wallet";
var GET_IFRAME_BASE_URL = () => `${i().replace("withpaper.com", "ews.thirdweb.com")}`;
var WALLET_USER_ID_LOCAL_STORAGE_NAME = (clientId) => `thirdwebEwsWalletUserId-${clientId}`;
var AUTH_TOKEN_LOCAL_STORAGE_PREFIX = "walletToken";
var AUTH_TOKEN_LOCAL_STORAGE_NAME = (clientId) => {
  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;
};
var DEVICE_SHARE_LOCAL_STORAGE_PREFIX = "a";
var DEVICE_SHARE_LOCAL_STORAGE_NAME = (clientId, userId) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;
var UserStatus = function(UserStatus2) {
  UserStatus2["LOGGED_OUT"] = "Logged Out";
  UserStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserStatus2;
}({});
var UserWalletStatus = function(UserWalletStatus2) {
  UserWalletStatus2["LOGGED_OUT"] = "Logged Out";
  UserWalletStatus2["LOGGED_IN_WALLET_UNINITIALIZED"] = "Logged In, Wallet Uninitialized";
  UserWalletStatus2["LOGGED_IN_NEW_DEVICE"] = "Logged In, New Device";
  UserWalletStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserWalletStatus2;
}({});
var data = /* @__PURE__ */ new Map();
var LocalStorage = class {
  constructor(_ref) {
    let {
      clientId
    } = _ref;
    this.isSupported = !!window.localStorage;
    this.clientId = clientId;
  }
  async getItem(key) {
    if (this.isSupported) {
      return window.localStorage.getItem(key);
    } else {
      return data.get(key) ?? null;
    }
  }
  async setItem(key, value) {
    if (this.isSupported) {
      return window.localStorage.setItem(key, value);
    } else {
      data.set(key, value);
    }
  }
  async removeItem(key) {
    const item = await this.getItem(key);
    if (this.isSupported && item) {
      window.localStorage.removeItem(key);
      return true;
    }
    return false;
  }
  async saveAuthCookie(cookie) {
    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);
  }
  async getAuthCookie() {
    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async removeAuthCookie() {
    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveDeviceShare(share, userId) {
    await this.saveWalletUserId(userId);
    await this.setItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId), share);
  }
  async getDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.getItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return null;
  }
  async removeDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.removeItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return false;
  }
  async getWalletUserId() {
    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveWalletUserId(userId) {
    await this.setItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId), userId);
  }
  async removeWalletUserId() {
    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
};
function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, seconds * 1e3);
  });
}
var iframeBaseStyle = {
  height: "100%",
  width: "100%",
  border: "none",
  backgroundColor: "transparent",
  colorScheme: "light",
  position: "fixed",
  top: "0px",
  right: "0px",
  zIndex: "2147483646",
  display: "none"
};
var isIframeLoaded = /* @__PURE__ */ new Map();
var IframeCommunicator = class {
  constructor(_ref) {
    let {
      link,
      iframeId,
      container = document.body,
      iframeStyles,
      onIframeInitialize
    } = _ref;
    _defineProperty(this, "POLLING_INTERVAL_SECONDS", 1.4);
    this.iframeBaseUrl = GET_IFRAME_BASE_URL();
    let iframe = document.getElementById(iframeId);
    const hrefLink = new URL(link);
    const sdkVersion = "1.3.4";
    hrefLink.searchParams.set("sdkVersion", sdkVersion);
    if (!iframe || iframe.src !== hrefLink.href) {
      if (!iframe) {
        iframe = document.createElement("iframe");
        const mergedIframeStyles = {
          ...iframeBaseStyle,
          ...iframeStyles
        };
        Object.assign(iframe.style, mergedIframeStyles);
        iframe.setAttribute("id", iframeId);
        iframe.setAttribute("fetchpriority", "high");
        container.appendChild(iframe);
      }
      iframe.src = hrefLink.href;
      iframe.setAttribute("data-version", sdkVersion);
      const onIframeLoaded = (event) => {
        if (event.data.eventType === "ewsIframeLoaded") {
          window.removeEventListener("message", onIframeLoaded);
          if (!iframe) {
            console.warn("thirdweb Iframe not found");
            return;
          }
          this.onIframeLoadHandler(iframe, onIframeInitialize)();
        }
      };
      window.addEventListener("message", onIframeLoaded);
    }
    this.iframe = iframe;
  }
  async onIframeLoadedInitVariables() {
    return {};
  }
  onIframeLoadHandler(iframe, onIframeInitialize) {
    return async () => {
      const promise = new Promise(async (res, rej) => {
        var _a;
        const channel = new MessageChannel();
        channel.port1.onmessage = (event) => {
          const {
            data: data2
          } = event;
          channel.port1.close();
          if (!data2.success) {
            return rej(new Error(data2.error));
          }
          isIframeLoaded.set(iframe.src, true);
          if (onIframeInitialize) {
            onIframeInitialize();
          }
          return res(true);
        };
        const INIT_IFRAME_EVENT = "initIframe";
        (_a = iframe == null ? void 0 : iframe.contentWindow) == null ? void 0 : _a.postMessage(
          // ? We initialise the iframe with a bunch
          // of useful information so that we don't have to pass it
          // through in each of the future call. This would be where we do it.
          {
            eventType: INIT_IFRAME_EVENT,
            data: await this.onIframeLoadedInitVariables()
          },
          this.iframeBaseUrl,
          [channel.port2]
        );
      });
      await promise;
    };
  }
  async call(_ref2) {
    let {
      procedureName,
      params,
      showIframe = false
    } = _ref2;
    while (!isIframeLoaded.get(this.iframe.src)) {
      await sleep(this.POLLING_INTERVAL_SECONDS);
    }
    if (showIframe) {
      this.iframe.style.display = "block";
      await sleep(5e-3);
    }
    const promise = new Promise((res, rej) => {
      var _a;
      const channel = new MessageChannel();
      channel.port1.onmessage = async (event) => {
        const {
          data: data2
        } = event;
        channel.port1.close();
        if (showIframe) {
          await sleep(0.1);
          this.iframe.style.display = "none";
        }
        if (!data2.success) {
          rej(new Error(data2.error));
        } else {
          res(data2.data);
        }
      };
      (_a = this.iframe.contentWindow) == null ? void 0 : _a.postMessage({
        eventType: procedureName,
        data: params
      }, this.iframeBaseUrl, [channel.port2]);
    });
    return promise;
  }
  /**
   * This has to be called by any iframe that will be removed from the DOM.
   * Use to make sure that we reset the global loaded state of the particular iframe.src
   */
  destroy() {
    isIframeLoaded.delete(this.iframe.src);
  }
};
var EmbeddedWalletIframeCommunicator = class extends IframeCommunicator {
  constructor(_ref) {
    let {
      clientId,
      customizationOptions
    } = _ref;
    super({
      iframeId: EMBEDDED_WALLET_IFRAME_ID,
      link: createEmbeddedWalletIframeLink({
        clientId,
        path: EMBEDDED_WALLET_PATH,
        queryParams: customizationOptions
      }).href,
      container: document.body
    });
    this.clientId = clientId;
  }
  async onIframeLoadedInitVariables() {
    const localStorage2 = new LocalStorage({
      clientId: this.clientId
    });
    return {
      authCookie: await localStorage2.getAuthCookie(),
      deviceShareStored: await localStorage2.getDeviceShare(),
      walletUserId: await localStorage2.getWalletUserId(),
      clientId: this.clientId
    };
  }
};
function createEmbeddedWalletIframeLink(_ref2) {
  var _a;
  let {
    clientId,
    path,
    queryParams
  } = _ref2;
  const embeddedWalletUrl = new URL(`${path}`, GET_IFRAME_BASE_URL());
  if (queryParams) {
    for (const queryKey of Object.keys(queryParams)) {
      embeddedWalletUrl.searchParams.set(queryKey, ((_a = queryParams[queryKey]) == null ? void 0 : _a.toString()) || "");
    }
  }
  embeddedWalletUrl.searchParams.set("clientId", clientId);
  return embeddedWalletUrl;
}
var EMBEDDED_WALLET_IFRAME_ID = "thirdweb-embedded-wallet-iframe";
var AbstractLogin = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * Call {@link EmbeddedWalletSdk.auth} instead.
   *
   */
  constructor(_ref) {
    let {
      querier,
      preLogin,
      postLogin,
      clientId
    } = _ref;
    this.LoginQuerier = querier;
    this.preLogin = preLogin;
    this.postLogin = postLogin;
    this.clientId = clientId;
  }
  async sendEmailLoginOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "sendThirdwebEmailLoginOtp",
      params: {
        email
      }
    });
    return result;
  }
};
var BaseLogin = class extends AbstractLogin {
  constructor() {
    super(...arguments);
    _defineProperty(this, "closeWindow", (_ref) => {
      let {
        isWindowOpenedByFn,
        win,
        closeOpenedWindow
      } = _ref;
      if (isWindowOpenedByFn) {
        win == null ? void 0 : win.close();
      } else {
        if (win && closeOpenedWindow) {
          closeOpenedWindow(win);
        } else if (win) {
          win.close();
        }
      }
    });
  }
  async getGoogleLoginUrl() {
    const result = await this.LoginQuerier.call({
      procedureName: "getHeadlessGoogleLoginLink",
      params: void 0
    });
    return result;
  }
  async loginWithModal() {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: void 0,
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithEmailOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: {
        email
      },
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithGoogle(args) {
    await this.preLogin();
    let win = args == null ? void 0 : args.openedWindow;
    let isWindowOpenedByFn = false;
    if (!win) {
      win = window.open("", "Login", "width=350, height=500");
      isWindowOpenedByFn = true;
    }
    if (!win) {
      throw new Error("Something went wrong opening pop-up");
    }
    await this.preLogin();
    const {
      loginLink
    } = await this.getGoogleLoginUrl();
    win.location.href = loginLink;
    const result = await new Promise((resolve, reject) => {
      const pollTimer = window.setInterval(async () => {
        if (!win) {
          return;
        }
        if (win.closed) {
          clearInterval(pollTimer);
          window.removeEventListener("message", messageListener);
          reject(new Error("User closed login window"));
        }
      }, 1e3);
      const messageListener = async (event) => {
        if (event.origin !== GET_IFRAME_BASE_URL()) {
          return;
        }
        if (typeof event.data !== "object") {
          reject(new Error("Invalid event data"));
          return;
        }
        switch (event.data.eventType) {
          case "userLoginSuccess": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            if (event.data.authResult) {
              resolve(event.data.authResult);
            }
            break;
          }
          case "userLoginFailed": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            reject(new Error(event.data.error));
            break;
          }
          case "injectDeveloperClientId": {
            win == null ? void 0 : win.postMessage({
              eventType: "injectDeveloperClientIdResult",
              developerClientId: this.clientId
            }, GET_IFRAME_BASE_URL());
            break;
          }
        }
      };
      window.addEventListener("message", messageListener);
    });
    return this.postLogin({
      storedToken: {
        ...result.storedToken,
        shouldStoreCookieString: true
      },
      walletDetails: {
        ...result.walletDetails,
        isIframeStorageEnabled: false
      }
    });
  }
  async verifyEmailLoginOtp(_ref3) {
    let {
      email,
      otp
    } = _ref3;
    const result = await this.LoginQuerier.call({
      procedureName: "verifyThirdwebEmailLoginOtp",
      params: {
        email,
        otp
      }
    });
    return this.postLogin(result);
  }
};
var Auth = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * Call {@link EmbeddedWalletSdk.auth} instead.
   *
   * @param {string} params.clientId the clientId from your thirdweb dashboard
   */
  constructor(_ref) {
    let {
      clientId,
      querier,
      onAuthSuccess
    } = _ref;
    this.clientId = clientId;
    this.AuthQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
    this.onAuthSuccess = onAuthSuccess;
    this.BaseLogin = new BaseLogin({
      postLogin: async (result) => {
        return this.postLogin(result);
      },
      preLogin: async () => {
        await this.preLogin();
      },
      querier,
      clientId
    });
  }
  async preLogin() {
    await this.logout();
  }
  async postLogin(_ref2) {
    let {
      storedToken,
      walletDetails
    } = _ref2;
    if (storedToken.shouldStoreCookieString) {
      await this.localStorage.saveAuthCookie(storedToken.cookieString);
    }
    const initializedUser = await this.onAuthSuccess({
      storedToken,
      walletDetails
    });
    return initializedUser;
  }
  /**
   * @description
   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers
   *
   * @example
   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "YOUR_CLIENT_ID", chain: "Polygon"})
   * try {
   *   const user = await thirdwebEmbeddedWallet.auth.loginWithModal();
   *   // user is now logged in
   * } catch (e) {
   *   // User closed modal or something else went wrong during the authentication process
   *   console.error(e)
   * }
   *
   * @param {(userWalletId: string) => Promise<string | undefined>} args.getRecoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. A function that returns the recovery code for a given userWalletId.
   *
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
   */
  async loginWithModal() {
    await this.preLogin();
    return this.BaseLogin.loginWithModal();
  }
  /**
   * @description
   * Used to log the user into their thirdweb wallet using email OTP
   *
   * @example
   *  // Basic Flow
   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   *  try {
   *    // prompts user to enter the code they received
   *    const user = await thirdwebEmbeddedWallet.auth.loginWithThirdwebEmailOtp({ email : "you@example.com" });
   *    // user is now logged in
   *  } catch (e) {
   *    // User closed the OTP modal or something else went wrong during the authentication process
   *    console.error(e)
   *  }
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
   */
  async loginWithEmailOtp(args) {
    return this.BaseLogin.loginWithEmailOtp(args);
  }
  async loginWithGoogle(args) {
    return this.BaseLogin.loginWithGoogle(args);
  }
  /**
   * A headless way to initiate login with google.
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
    */
  /**
   * @description
   * A headless way to send the users at {email} an OTP code.
   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process
   *
   * @example
   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   *  // sends user an OTP code
   * try {
   *    await thirdwebEmbeddedWallet.auth.sendEmailLoginOtp({ email : "you@example.com" });
   * } catch(e) {
   *    // Error Sending user's email an OTP code
   *    console.error(e);
   * }
   *
   * // Then when your user is ready to verify their OTP
   * try {
   *    const user = await thirdwebEmbeddedWallet.auth.verifyEmailLoginOtp({ email: "you@example.com", otp: "6-DIGIT_CODE_HERE" });
   * } catch(e) {
   *    // Error verifying the OTP code
   *    console.error(e)
   * }
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns {{ isNewUser: boolean }} IsNewUser indicates if the user is a new user to your platform
   */
  async sendEmailLoginOtp(_ref3) {
    let {
      email
    } = _ref3;
    return this.BaseLogin.sendEmailLoginOtp({
      email
    });
  }
  /**
   *  @description
   * Used to verify the otp that the user receives from thirdweb
   *
   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @param {string} props.otp The code that the user received in their email
   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more
   */
  async verifyEmailLoginOtp(args) {
    return this.BaseLogin.verifyEmailLoginOtp(args);
  }
  /**
   * @description
   * Logs any existing user out of their wallet.
   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.
   */
  async logout() {
    const {
      success
    } = await this.AuthQuerier.call({
      procedureName: "logout",
      params: void 0
    });
    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();
    const isRemoveUserId = await this.localStorage.removeWalletUserId();
    return {
      success: success || isRemoveAuthCookie || isRemoveUserId
    };
  }
};
var EthersSigner = class _EthersSigner extends Signer {
  constructor(_ref) {
    var _a;
    let {
      provider,
      clientId,
      querier
    } = _ref;
    super();
    _defineProperty(this, "DEFAULT_ETHEREUM_CHAIN_ID", 5);
    this.clientId = clientId;
    this.querier = querier;
    this.endpoint = (_a = provider.connection) == null ? void 0 : _a.url;
    (0, import_utils2.defineReadOnly)(this, "provider", provider);
  }
  async getAddress() {
    const {
      address
    } = await this.querier.call({
      procedureName: "getAddress",
      params: void 0
    });
    return address;
  }
  async signMessage(message) {
    var _a, _b;
    const {
      signedMessage
    } = await this.querier.call({
      procedureName: "signMessage",
      params: {
        message,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedMessage;
  }
  async signTransaction(transaction) {
    var _a, _b;
    const {
      signedTransaction
    } = await this.querier.call({
      procedureName: "signTransaction",
      params: {
        transaction,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTransaction;
  }
  async _signTypedData(domain, types, message) {
    var _a, _b;
    const {
      signedTypedData
    } = await this.querier.call({
      procedureName: "signTypedDataV4",
      params: {
        domain,
        types,
        message,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTypedData;
  }
  connect(provider) {
    return new _EthersSigner({
      clientId: this.clientId,
      provider,
      querier: this.querier
    });
  }
};
var EmbeddedWallet = class {
  /**
   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance
   * @param param0
   */
  constructor(_ref) {
    let {
      clientId,
      chain,
      querier
    } = _ref;
    this.clientId = clientId;
    this.chain = chain;
    this.walletManagerQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
  }
  /**
   * @internal
   * Used to set-up the user device in the case that they are using incognito
   * @param {string} param.deviceShareStored the value that is saved for the user's device share.
   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.
   * This happens in incognito mostly
   * @param {string} param.walletAddress User's wallet address
   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.
   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe
   * @returns {{ walletAddress : string }} The user's wallet details
   */
  async postWalletSetUp(_ref2) {
    let {
      deviceShareStored,
      walletAddress,
      isIframeStorageEnabled,
      walletUserId
    } = _ref2;
    if (!isIframeStorageEnabled) {
      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);
    }
    return {
      walletAddress
    };
  }
  /**
   * @internal
   * Gets the various status states of the user
   * @example
   *  const userStatus = await Paper.getUserWalletStatus();
   *  switch (userStatus.status) {
   *  case UserWalletStatus.LOGGED_OUT: {
   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {
   *    // User is logged in, but does not have a wallet associated with it
   *    // you also have access to the user's details
   *    userStatus.user.authDetails;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {
   *    // User is logged in and created a wallet already, but is missing the device shard
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *    // user is logged in and wallet is all set up.
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    userStatus.user.wallet;
   *    break;
   *  }
   *}
   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses
   */
  async getUserWalletStatus() {
    const userStatus = await this.walletManagerQuerier.call({
      procedureName: "getUserStatus",
      params: void 0
    });
    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
        user: {
          ...userStatus.user,
          wallet: this
        }
      };
    }
    return userStatus;
  }
  /**
   * @description
   * Switches the chain that the user wallet is currently on.
   * @example
   * // user wallet will be set to Polygon
   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   * const user = await Paper.initializeUser();
   * // Switch the user wallet to Mumbai
   * await user.wallet.setChain({ chain: "Mumbai" });
   * @param {Chain} params.chain The chain that we are changing the user wallet too
   */
  async setChain(_ref3) {
    let {
      chain
    } = _ref3;
    this.chain = chain;
  }
  /**
   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp
   * @example
   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   * const user = await Paper.getUser();
   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {
   *    // returns a signer on the Polygon mainnet
   *    const signer = await user.getEthersJsSigner();
   *    // returns a signer on the specified RPC endpoints
   *    const signer = await user.getEthersJsSigner({rpcEndpoint: "https://eth-rpc.gateway.pokt.network"});
   * }
   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through
   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link ThirdwebEmbeddedWalletSdk.initializeUser} before accessing this function
   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link ThirdwebEmbeddedWalletSdk} instance
   */
  async getEthersJsSigner(network) {
    const signer = new EthersSigner({
      clientId: this.clientId,
      provider: getDefaultProvider((network == null ? void 0 : network.rpcEndpoint) ?? e[this.chain]),
      querier: this.walletManagerQuerier
    });
    return signer;
  }
};
var EmbeddedWalletSdk = class {
  /**
   * Used to manage the Auth state of the user.
   */
  isClientIdLegacyPaper(clientId) {
    if (clientId.indexOf("-") > 0 && clientId.length === 36) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * @example
   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({ clientId: "", chain: "Goerli" });
   * @param {string} initParams.clientId the clientId found on the {@link https://thirdweb.com/dashboard/settings dashboard settings}
   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.
   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.
   */
  constructor(_ref) {
    let {
      clientId,
      chain,
      styles
    } = _ref;
    if (this.isClientIdLegacyPaper(clientId)) {
      throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
    }
    this.clientId = clientId;
    this.querier = new EmbeddedWalletIframeCommunicator({
      clientId,
      customizationOptions: styles
    });
    this.wallet = new EmbeddedWallet({
      clientId,
      chain,
      querier: this.querier
    });
    this.auth = new Auth({
      clientId,
      querier: this.querier,
      onAuthSuccess: async (authResult) => {
        await this.wallet.postWalletSetUp({
          ...authResult.walletDetails,
          walletUserId: authResult.storedToken.authDetails.userWalletId
        });
        await this.querier.call({
          procedureName: "initIframe",
          params: {
            deviceShareStored: authResult.walletDetails.deviceShareStored,
            clientId: this.clientId,
            walletUserId: authResult.storedToken.authDetails.userWalletId,
            authCookie: authResult.storedToken.cookieString
          }
        });
        return {
          user: {
            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
            authDetails: authResult.storedToken.authDetails,
            wallet: this.wallet,
            walletAddress: authResult.walletDetails.walletAddress
          }
        };
      }
    });
  }
  /**
   * Gets the usr if they are logged in
   * @example
   *  const user = await thirdwebEmbeddedWallet.getUser();
   *  switch (user.status) {
   *     case UserStatus.LOGGED_OUT: {
   *       // User is logged out, call one of the auth methods on thirdwebEmbeddedWallet.auth to authenticate the user
   *       break;
   *     }
   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *       // user is logged in and wallet is all set up.
   *       // You have access to:
   *       user.status;
   *       user.authDetails;
   *       user.walletAddress;
   *       user.wallet;
   *       break;
   *     }
   *}
   * @returns {GetUser} an object to containing various information on the user statuses
   */
  async getUser() {
    const userStatus = await this.wallet.getUserWalletStatus();
    switch (userStatus.status) {
      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:
      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:
        await this.auth.logout();
        return this.getUser();
      case UserWalletStatus.LOGGED_OUT:
        return {
          status: UserStatus.LOGGED_OUT
        };
      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:
        return {
          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
          ...userStatus.user
        };
    }
  }
};

// node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
var import_utils3 = __toESM(require_utils());
var _embeddedWalletSdk = /* @__PURE__ */ new WeakMap();
var _signer = /* @__PURE__ */ new WeakMap();
var EmbeddedWalletConnector = class extends Connector {
  constructor(options) {
    super();
    _defineProperty(this, "id", walletIds.paper);
    _defineProperty(this, "name", "Paper Wallet");
    _defineProperty(this, "ready", true);
    _defineProperty(this, "user", null);
    _classPrivateFieldInitSpec(this, _embeddedWalletSdk, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _signer, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", async (accounts) => {
      if (accounts.length === 0) {
        await this.onDisconnect();
      } else {
        this.emit("change", {
          account: utils_exports.getAddress(accounts[0])
        });
      }
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.options.chains.findIndex((c) => c.chainId === id) === -1;
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", async () => {
      this.emit("disconnect");
    });
    this.options = options;
  }
  getEmbeddedWalletSDK() {
    if (!_classPrivateFieldGet(this, _embeddedWalletSdk)) {
      _classPrivateFieldSet(this, _embeddedWalletSdk, new EmbeddedWalletSdk({
        clientId: this.options.clientId,
        chain: "Ethereum",
        styles: this.options.styles
      }));
    }
    return _classPrivateFieldGet(this, _embeddedWalletSdk);
  }
  async connect(options) {
    const thirdwebSDK = await this.getEmbeddedWalletSDK();
    if (!thirdwebSDK) {
      throw new Error("EmbeddedWallet SDK not initialized");
    }
    const user = await thirdwebSDK.getUser();
    switch (user.status) {
      case UserStatus.LOGGED_OUT: {
        let authResult;
        switch (options == null ? void 0 : options.loginType) {
          case "headless_google_oauth": {
            authResult = await thirdwebSDK.auth.loginWithGoogle({
              closeOpenedWindow: options.closeOpenedWindow,
              openedWindow: options.openedWindow
            });
            break;
          }
          case "headless_email_otp_verification": {
            authResult = await thirdwebSDK.auth.verifyEmailLoginOtp({
              email: options.email,
              otp: options.otp
            });
            break;
          }
          case "ui_email_otp": {
            authResult = await thirdwebSDK.auth.loginWithEmailOtp({
              email: options.email
            });
            break;
          }
          default: {
            authResult = await thirdwebSDK.auth.loginWithModal();
            break;
          }
        }
        this.user = authResult.user;
        break;
      }
      case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
        if ((options == null ? void 0 : options.loginType) === "headless_google_oauth") {
          if (options.closeOpenedWindow && options.openedWindow) {
            options.closeOpenedWindow(options.openedWindow);
          }
        }
        this.user = user;
        break;
      }
    }
    if (!this.user) {
      throw new Error("Error connecting User");
    }
    if (options == null ? void 0 : options.chainId) {
      this.switchChain(options.chainId);
    }
    this.setupListeners();
    return this.getAddress();
  }
  async disconnect() {
    const paper = await _classPrivateFieldGet(this, _embeddedWalletSdk);
    await (paper == null ? void 0 : paper.auth.logout());
    _classPrivateFieldSet(this, _signer, void 0);
    this.user = null;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async isConnected() {
    try {
      const addr = await this.getAddress();
      return !!addr;
    } catch (e2) {
      return false;
    }
  }
  async getProvider() {
    const signer = await this.getSigner();
    if (!signer.provider) {
      throw new Error("Provider not found");
    }
    return signer.provider;
  }
  async getSigner() {
    var _a;
    if (_classPrivateFieldGet(this, _signer)) {
      return _classPrivateFieldGet(this, _signer);
    }
    if (!this.user) {
      const embeddedWalletSdk = await this.getEmbeddedWalletSDK();
      const user = await embeddedWalletSdk.getUser();
      switch (user.status) {
        case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
          this.user = user;
          break;
        }
      }
    }
    const signer = await ((_a = this.user) == null ? void 0 : _a.wallet.getEthersJsSigner({
      rpcEndpoint: this.options.chain.rpc[0] || ""
      // TODO: handle chain.rpc being empty array
    }));
    if (!signer) {
      throw new Error("Signer not found");
    }
    _classPrivateFieldSet(this, _signer, signer);
    return signer;
  }
  async isAuthorized() {
    return false;
  }
  async switchChain(chainId) {
    var _a, _b;
    const chain = this.options.chains.find((c) => c.chainId === chainId);
    if (!chain) {
      throw new Error("Chain not configured");
    }
    await ((_a = this.user) == null ? void 0 : _a.wallet.setChain({
      chain: "Ethereum"
    }));
    _classPrivateFieldSet(this, _signer, await ((_b = this.user) == null ? void 0 : _b.wallet.getEthersJsSigner({
      rpcEndpoint: chain.rpc[0] || ""
      // TODO: handle chain.rpc being empty array
    })));
    this.emit("change", {
      chain: {
        id: chainId,
        unsupported: false
      }
    });
  }
  async setupListeners() {
    const provider = await this.getProvider();
    if (provider.on) {
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
    }
  }
  updateChains(chains) {
    this.options.chains = chains;
  }
  async getEmail() {
    await this.getSigner();
    if (!this.user) {
      throw new Error("No user found, Paper Wallet is not connected");
    }
    return this.user.authDetails.email;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
var import_utils4 = __toESM(require_utils());
var EmbeddedWallet2 = class _EmbeddedWallet extends AbstractClientWallet {
  get walletName() {
    return "Embedded Wallet";
  }
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    this.chain = options.chain;
  }
  async getConnector() {
    var _a, _b;
    if (!this.connector) {
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a = this.options) == null ? void 0 : _a.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        styles: (_b = this.options) == null ? void 0 : _b.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (connectParams.loginType === "headless_google_oauth") {
      return {
        loginType: connectParams.loginType,
        chainId: connectParams.chainId
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
};
_defineProperty(EmbeddedWallet2, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet2, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-UJNPZC7Y.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-O6JB4DIQ.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(_LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-W7B6MSUA.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || c1,
        ethersWallet: this.ethersWallet,
        chains: this.options.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * load saved wallet data from storage or generate a new one and save it.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * creates a new random wallet
   * @returns the address of the newly created wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * create local wallet from an "encryptedJson", "privateKey" or "mnemonic"
   * @returns
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * initialize the wallet from saved data on storage
   * @param password - password used for encrypting the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * @returns true if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data2 = await this.getSavedData();
      const address = await this.getAddress();
      if ((data2 == null ? void 0 : data2.address) === address) {
        return true;
      }
      return false;
    } catch (e2) {
      return false;
    }
  }
  /**
   * deletes the saved wallet data from storage
   */
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * encrypts the wallet with given password and returns the encrypted wallet
   * @param password - password for encrypting the wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   */
  async getSavedData(storage) {
    const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
    try {
      const savedDataStr = await _storage3.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e2) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data2, storage) {
  const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
  await _storage3.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data2));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-XVCNMRQC.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-XVCNMRQC.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_lib3();
var _storage = /* @__PURE__ */ new WeakMap();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    this.options = options;
    this.signer = options.signer;
    _classPrivateFieldSet(this, _storage, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-VUMICAVW.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new SignerConnector({
        chain: this.options.chain || c1,
        signer: this.signer,
        chains: this.options.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-4VENGHQJ.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-7SVKI5CU.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-DHGPIYNT.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  get walletName() {
    return "Phantom";
  }
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-V45LRYWB.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-LYNGHKRX.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-DHGPIYNT.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_lib3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-ATIE5R7S.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-PC3QTLYG.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-DHGPIYNT.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * trust.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data2) => {
        _classPrivateFieldSet(this, _provider, data2.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("display_uri", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("wc_session_request_sent");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-DHGPIYNT.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = _classPrivateFieldGet(this, _walletConnectConnector);
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-2WX5TIUA.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-DHGPIYNT.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/auth-e91a1229.browser.esm.js
var RecoveryShareManagement = function(RecoveryShareManagement2) {
  RecoveryShareManagement2["USER_MANAGED"] = "USER_MANAGED";
  RecoveryShareManagement2["AWS_MANAGED"] = "AWS_MANAGED";
  return RecoveryShareManagement2;
}({});
var AuthProvider = function(AuthProvider2) {
  AuthProvider2["COGNITO"] = "Cognito";
  return AuthProvider2;
}({});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
var import_buffer2 = __toESM(require_buffer());
var import_utils5 = __toESM(require_utils());

export {
  createAsyncLocalStorage,
  SmartWallet,
  getInjectedCoinbaseProvider,
  PaperWallet,
  BloctoWallet,
  CoinbaseWallet,
  EmbeddedWallet2 as EmbeddedWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  SignerWallet,
  MagicLink,
  MetaMaskWallet,
  PhantomWallet,
  RainbowWallet,
  SafeWallet,
  TrustWallet,
  WalletConnect,
  ZerionWallet
};
//# sourceMappingURL=chunk-CC7GU5KR.js.map
